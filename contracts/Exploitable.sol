pragma solidity 0.5.0;

import "./Negotiator.sol";

contract Exploitable {
    mapping(address => uint256) public balances;
    address payable[] public investors;

    Negotiator public negotiator;
    address payable public owner;
    uint256 public bounty;

    constructor(Negotiator _negotiator) public {
        owner = msg.sender;
        negotiator = _negotiator;
    }

    function() payable external {
        deposit();
    }

    function deposit() payable public {
        investors.push(msg.sender);
        balances[msg.sender] += msg.value;    
    }

    function withdraw() public { 
        // Remove msg.sender from the investors list
        for (uint256 i = 0; i < investors.length; i++) {
            if (investors[i] == msg.sender) {
                investors[i] = investors[investors.length-1];
                break;
            }
        }
        balances[msg.sender] = 0;
        msg.sender.transfer(balances[msg.sender]);
    }

    function pay(uint256 bountyId, string memory publicKey) public {
        require(msg.sender == owner);
        negotiator.pay.value(bounty)(bountyId, publicKey);
    }

    function decide(uint256 bountyId, bool decision) public {
        require(msg.sender == owner);
        negotiator.decide(bountyId, decision);
    }

    function restore() payable public {
        require(tx.origin == owner);
        require(msg.sender == address(negotiator));
        bounty += msg.value;
    }

    function exit() public {
        require(tx.origin == owner);
        require(msg.sender == address(negotiator));

        // TODO: Send to Claimable contract instead of paying out directly.
        for (uint256 i = 0; i < investors.length; i++) {
            uint256 balance = balances[investors[i]];
            // send non-blocking so that function doesn't fail
            investors[i].send(balance);
        }
    }

    function implementsExploitable() public pure returns (bool) {
        return true;
    }
}
