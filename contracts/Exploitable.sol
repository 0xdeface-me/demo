pragma solidity ^0.5.2;

import "./Negotiator.sol";
import "openzeppelin-solidity/contracts/math/SafeMath.sol";

contract Exploitable {
    using SafeMath for uint256;

    mapping(address => uint256) public balances;
    address payable[] public investors;

    Negotiator public negotiator;
    address payable public owner;
    uint256 public bounty;

    constructor(Negotiator negotiator) public {
        owner = msg.sender;
        negotiator = negotiator;
    }

    function() external payable {
        deposit();
    }

    function deposit() public payable {
        investors.push(msg.sender);
        balances[msg.sender] = balances[msg.sender].add(msg.value);
    }

    function withdraw() public { 
        // Remove msg.sender from the investors list
        for (uint256 i = 0; i < investors.length; i++) {
            if (investors[i] == msg.sender) {
                investors[i] = investors[investors.length-1];
                break;
            }
        }
        balances[msg.sender] = 0;
        msg.sender.transfer(balances[msg.sender]);
    }

    function increaseBounty() public payable{
        require(msg.sender == owner, "Only owner can increase bounty");
        bounty = bounty.add(msg.value);
    }

    function decreaseBounty(uint256 amount) public {
        require(msg.sender == owner, "Only owner can decrease bounty");
        bounty = bounty.sub(amount);
        msg.sender.transfer(amount);
    }

    function pay(uint256 bountyId, string memory publicKey) public {
        require(msg.sender == owner, "Only owner can pay bounty");
        negotiator.pay.value(bounty)(bountyId, publicKey);
        bounty = bounty.sub(bounty);
    }

    function decide(
        uint256 bountyId,
        bool decision,
        string memory reason
    ) public {
        require(msg.sender == owner, "Only owner can make a decision");
        negotiator.decide(bountyId, decision, reason);
    }

    function restore() public payable {
        // solium-disable security/no-tx-origin
        require(tx.origin == owner, "Owner can initiate restore");
        require(
            msg.sender == address(negotiator),
            "Only negotiator can restore"
        );
        bounty = bounty.add(msg.value);
    }

    function exit() public {
        require(tx.origin == owner, "Only owner can inititiate exit");
        require(msg.sender == address(negotiator), "Only negotiator can exit");

        // TODO: Send to Claimable contract instead of paying out directly.
        for (uint256 i = 0; i < investors.length; i++) {
            uint256 balance = balances[investors[i]];
            // decrease investor credit to zero
            balances[investors[i]] = 0;
            // send non-blocking so that function doesn't fail
            // solium-disable security/no-send
            investors[i].send(balance);
        }
    }

    function implementsExploitable() public pure returns (bool) {
        return true;
    }
}
