pragma solidity 0.5.0;

import "./ZeroDay.sol";

contract Exploitable {
    mapping(address => uint256) public balances;
    address payable[] public investors;

    ZeroDay public zeroDay;
    address payable public owner;

    constructor(ZeroDay _zeroDay) public {
        owner = msg.sender;
        zeroDay = _zeroDay; 
    }

    function deposit() payable public {
        investors.push(msg.sender);
        balances[msg.sender] += msg.value;    
    }

    function withdraw() public { 
        // Remove msg.sender from the investors list
        for (uint256 i = 0; i < investors.length; i++) {
            if (investors[i] == msg.sender) {
                investors[i] = investors[investors.length-1];
                break;
            }
        }
        balances[msg.sender] = 0;
        msg.sender.transfer(balances[msg.sender]);
    }

    function pay(uint256 bountyId, string memory publicKey) public {
        require(msg.sender == owner);

        // Credit investors X% less as bounty is sent to zeroday
        for (uint256 i = 0; i < investors.length; i++) {
            uint256 balance = balances[investors[i]];
            balances[investors[i]] *= balance * ((100 - percentageZeroDay()) / 100);
        }
        uint256 bounty = address(this).balance * (percentageZeroDay() / 100);
        zeroDay.pay.value(bounty)(bountyId, publicKey);
    }

    function decide(uint256 bountyId, bool decision) public {
        require(msg.sender == owner);
        zeroDay.decide(bountyId, decision);
    }

    function restore() payable public {
        require(tx.origin == owner);
        require(msg.sender == address(zeroDay));

        // Increase investors balances after vulnerability has been declined
        for (uint256 i = 0; i < investors.length; i++) {
            uint256 balance = balances[investors[i]];
            balances[investors[i]] *= balance * ((percentageZeroDay() - 100) / 100);
        }
    }

    function exit() public {
        require(tx.origin == owner);
        require(msg.sender == address(zeroDay));

        for (uint256 i = 0; i < investors.length; i++) {
            uint256 balance = balances[investors[i]];
            // Subtract bounty amount from balance of investors
            uint256 balanceAfterBounty = balance * ((100 - percentageZeroDay()) / 100);

            // send non-blocking so that function doesn't fail
            investors[i].send(balanceAfterBounty);
        }
        selfdestruct(owner);
    }

    function implementsZeroDay() public pure returns (bool) {
        return true;
    }

    function percentageZeroDay() public pure returns (uint256) {
        return 10;
    }
}
