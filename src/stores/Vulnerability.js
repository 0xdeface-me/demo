//@format
import { observable, flow, computed } from "mobx";
import BigNumber from "bignumber.js";
import ecies from "eth-ecies";
import wallet from "ethereumjs-wallet";
import axios from "axios";

import config from "../config";

import Negotiator from "../../build/contracts/Negotiator";
import IExploitable from "../../build/contracts/IExploitable";
import sample from "../assets/sample";
import { netToEtherscanAPI } from "../utils/helpers";

class Vulnerability {
  @observable
  state = "pending";
  @observable
  id = -1;
  @observable
  exploitable = 0x0;
  @observable
  attacker = 0x0;
  @observable
  damage = "0";
  @observable
  key = 0x0;
  @observable
  bounty = "0";
  @observable
  hash = "";
  @observable
  status = -1;
  @observable
  balance = "0";
  @observable
  code = "";

  // Computed values
  @observable
  tmpbounty = 0;
  @observable
  publicKey = 0x0;
  @observable
  privateKey = 0x0;
  @observable
  decrypted = "";

  async negotiator(web3) {
    const networkId = await web3.eth.net.getId();
    if (Negotiator.networks[networkId]) {
      return new web3.eth.Contract(
        Negotiator.abi,
        Negotiator.networks[networkId].address
      );
    } else {
      return new web3.eth.Contract(
        Negotiator.abi,
        config.RINKEBY_TEST.NEGOTIATOR
      );
    }
  }

  async exploitableContract(web3, address) {
    const networkId = await web3.eth.net.getId();
    return new web3.eth.Contract(IExploitable.abi, address);
  }

  loadCode = flow(function*(web3) {
    this.state = "pending";

    const { hostname } = window.location;

    if (hostname === "localhost") {
      this.code = sample.result[0].SourceCode;
      this.state = "done";
    } else {
      try {
        let api = netToEtherscanAPI(config.TARGET_NETWORK);
        const data = (yield axios.get(
          "https://" +
            api +
            ".etherscan.io/api?module=contract&action=getsourcecode&address=" +
            this.exploitable
        )).data;
        this.state = "done";
      } catch (err) {
        console.log(err);
        this.state = "error";
      }

      const code = data.result[0].SourceCode;
      if (code !== "") {
        this.code = code;
        this.state = "done";
      }
    }
  });

  fetch = flow(function*(web3, account, id) {
    this.state = "pending";

    const contract = yield this.negotiator(web3);

    try {
      const {
        exploitable,
        attacker,
        damage,
        key,
        bounty,
        hash,
        status
      } = yield contract.methods.vulns(id).call({ from: account });
      this.id = id;
      this.exploitable = exploitable;
      this.attacker = attacker;
      this.damage = damage;
      this.key = key;
      this.bounty = bounty;
      this.hash = hash;
      this.status = status;
    } catch (err) {
      console.log(err);
      this.state = "error";
    }

    try {
      this.balance = yield web3.eth.getBalance(this.exploitable);
      this.state = "done";
    } catch (err) {
      console.log(err);
      this.state = "error";
    }
  });

  compute = flow(function*(web3, account, id) {
    this.state = "pending";

    try {
      // TODO: Put these statements into separate try catch clauses
      yield this.fetch(web3, account, id);

      const exploitable = yield this.exploitableContract(
        web3,
        this.exploitable
      );

      const damage = new BigNumber(this.damage);
      const percentage = new BigNumber(
        yield exploitable.methods.percentageEIP1337().call({ from: account })
      );
      const tmpbounty = damage.multipliedBy(percentage.dividedBy(100));
      this.tmpbounty = tmpbounty.toString();
      this.state = "done";
    } catch (err) {
      console.log(err);
      this.state = "error";
    }

    let { privateKey } = web3.eth.accounts.create();
    privateKey = privateKey.substring(2, privateKey.length);

    this.publicKey = wallet
      .fromPrivateKey(new Buffer(privateKey, "hex"))
      .getPublicKeyString();
    this.privateKey = "0x" + privateKey;
  });

  pay = flow(function*(web3, account, id) {
    this.state = "pending";

    // NOTE: We're assuming Vulnerability's values have been set by now.
    const exploitable = yield this.exploitableContract(web3, this.exploitable);
    try {
      yield exploitable.methods.pay(id, this.publicKey).send({ from: account });
      this.state = "done";
    } catch (err) {
      console.log(err);
      this.state = "error";
    }
  });

  reveal = flow(function*(web3, ipfs, account, id, vuln) {
    this.state = "pending";

    // TODO: Put these statements into separate try catch clauses
    yield this.fetch(web3, account, id);

    const key = this.key.substring(2, this.key.length);
    const userPublicKey = new Buffer(key, "hex");
    const bufferData = new Buffer(vuln);
    const encryptedData = ecies.encrypt(userPublicKey, bufferData);

    const contract = yield this.negotiator(web3);
    const hash = (yield ipfs.add(
      new Buffer(encryptedData.toString("base64"))
    ))[0]["hash"];
    console.log(hash);

    try {
      yield contract.methods.reveal(id, hash).send({ from: account });
    } catch (err) {
      console.log(err);
      this.state = "error";
    }
  });

  decrypt = flow(function*(web3, account, id, key) {
    this.state = "pending";

    try {
      yield this.fetch(web3, account, id);
    } catch (err) {
      console.log(err);
      this.state = "error";
    }

    let vuln;
    try {
      vuln = (yield axios.get(
        `https://${config.IPFS_PROVIDER}/ipfs/${this.hash}`
      )).data;
    } catch (err) {
      console.log(err);
      this.state = "error";
    }

    key = key.substring(2, key.length);
    const keyBuffer = new Buffer(key, "hex");
    const vulnBuffer = new Buffer(vuln, "base64");

    let decrypted;
    try {
      decrypted = ecies.decrypt(keyBuffer, vulnBuffer);
    } catch (err) {
      console.log(err);
      this.state = "error";
    }
    this.decrypted = decrypted.toString("utf8");
    this.state = "done";
  });

  decide = flow(function*(web3, account, id, exit) {
    this.state = "pending";
    // NOTE: We assume that Vulnerability is fully loaded.
    // We don't call fetch here.

    const exploitable = yield this.exploitableContract(web3, this.exploitable);

    try {
      yield exploitable.methods.decide(id, exit).send({ from: account });
      this.state = "done";
    } catch (err) {
      console.log(err);
      this.state = "error";
    }
  });
}

export default Vulnerability;
