import {observable, flow, computed} from 'mobx';
import BigNumber from "bignumber.js"
import ecies from "eth-ecies";
import wallet from 'ethereumjs-wallet';
import axios from "axios";

import config from "../config";

import ZeroDay from "../../build/contracts/ZeroDay";
import IExploitable from "../../build/contracts/IExploitable";

class Vulnerability {
    @observable id = -1;
    @observable exploitable = 0x0;
    @observable hunter = 0x0;
    @observable damage = 0;
    @observable key = 0x0;
    @observable bounty = 0;
    @observable hash = "";
    @observable status = -1;

    // Computed values
    @observable tmpbounty = 0;
    @observable publicKey = 0x0;
    @observable privateKey = 0x0;
    @observable decrypted = "";

    async zeroDay(web3) {
        const networkId = await web3.eth.net.getId();
        return new web3.eth.Contract(
            ZeroDay.abi, ZeroDay.networks[networkId].address
        );
    }

    async exploitableContract(web3, address) {
        const networkId = await web3.eth.net.getId();
        return new web3.eth.Contract(
            IExploitable.abi, address
        );
    }

    fetch = flow(function * (web3, account, id) {
        this.state = "pending"; 

        const contract = yield this.zeroDay(web3);

        try {
            const {
               exploitable,
               hunter,
               damage,
               key,
               bounty,
               hash,
               status
            } = yield contract.methods.vulns(id).call({from: account});
            this.id = id;
            this.exploitable = exploitable;
            this.hunter = hunter;
            this.damage = damage;
            this.key = key;
            this.bounty = bounty;
            this.hash = hash;
            this.status = status;

            this.state = "done";
        } catch(err) {
            console.log(err);
            this.state = "error";
        }
    });

    compute = flow(function * (web3, account, id) {
        this.state = "pending";

        try {
            // TODO: Put these statements into separate try catch clauses
            yield this.fetch(web3, account, id);

            const exploitable = yield this.exploitableContract(
                web3,
                this.exploitable
            );
            
            const damage = new BigNumber(this.damage)
            const percentage = new BigNumber(
                yield exploitable.methods.percentageZeroDay()
                    .call({from: account })
            );
            const tmpbounty = damage.multipliedBy(percentage.dividedBy(100));
            this.tmpbounty = tmpbounty.toString();
            this.state = "done";
        } catch (err) {
            console.log(err);
            this.state = "error";
        }

        let { privateKey } = web3.eth.accounts.create();
        privateKey = privateKey.substring(2, privateKey.length);

        this.publicKey = wallet.fromPrivateKey(new Buffer(privateKey, 'hex'))
            .getPublicKeyString();
        this.privateKey = "0x"+privateKey;
    })

    pay = flow(function * (web3, account, id) {
        this.state = "pending";
        
        // NOTE: We're assuming Vulnerability's values have been set by now.
        const exploitable = yield this.exploitableContract(
            web3,
            this.exploitable
        )
        try {
            yield exploitable.methods.pay(id, this.publicKey)
                .send({from: account });
            this.state = "done";
        } catch (err) {
            console.log(err);
            this.state = "error";
        }
    });

    reveal = flow(function * (web3, ipfs, account, id, vuln) {
        this.state = "pending";

        // TODO: Put these statements into separate try catch clauses
        yield this.fetch(web3, account, id);

        const key = this.key.substring(2, this.key.length);
        const userPublicKey = new Buffer(key, 'hex');
        const bufferData = new Buffer(vuln);
        const encryptedData = ecies.encrypt(userPublicKey, bufferData);
         
        const contract = yield this.zeroDay(web3);
        const hash = (yield ipfs.add(
            new Buffer(encryptedData.toString('base64'))
        ))[0]['hash'];
        console.log(hash);

        try {
            yield contract.methods.reveal(id, hash).send({from: account });
        } catch (err) {
            console.log(err);
            this.state = "error";
        }
    });

    decrypt = flow(function * (web3, account, id, key) {
        this.state = "pending";

        try {
            yield this.fetch(web3, account, id);
        } catch(err) {
            console.log(err);
            this.state = "error";
        }

        let vuln;
        try {
            vuln = (yield axios
                .get(`https://${config.IPFS_PROVIDER}/ipfs/${this.hash}`)).data;
        } catch (err) {
            console.log(err);
            this.state = "error";
        }

        key = key.substring(2, key.length);
        const keyBuffer = new Buffer(key, 'hex');
        const vulnBuffer = new Buffer(vuln, 'base64');

        let decrypted;
        try {
            decrypted = ecies.decrypt(keyBuffer, vulnBuffer);
        } catch (err) {
            console.log(err);
            this.state = "error";
        }
        this.decrypted = decrypted.toString('utf8');
        this.state = "done";
    });
}

export default Vulnerability;
